# Incident Handler Example

The purpose of this example is to demonstrate using a custom Job Excutor and External Task incident handler to potentially send information about incidents to another system or alert about incidents while still handling incidents in Camunda and Cockpit.


## Running the use-case

```
mvn spring-boot:run -Dspring.profiles.active=incident
```

**Profiles** can be specified at the command line when the application starts. The notation is as follows.

`-Dspring.profiles.active=incident`

Or you can use the application.properties file to specify the profile.

```yaml
spring.profiles.active: incident
```

IMPORTANT: Using Camunda Enterprise - it's necessary to request a Camunda Enterprise License. https://camunda.com/download/enterprise/[Request License Here]


### Testing with Postman

Use the postman collection `Incident-PoC.postman_collection.json` in the `postman` folder.

With post-man you can move through the processes simulating REST requests to the app. Since its a very simple process to test the incident handler only need to start the process with postman.

### Testing with Java
Camunda allows developers to test in multiple scopes with the camunda-bpm-assert lib and the surrouding framework.
https://docs.camunda.org/manual/7.5/user-guide/testing/#junit-4[Testing Docs]

Camunda provides test coverage reports that integrate with the camunda-bpm-assert lib and the camunda-bpm-assert-scenario lib
https://github.com/camunda/camunda-bpm-process-test-coverage[Test Coverage]

camunda-bpm-assert-scenario is an abstraction on the camunda-bpm-assert lib
https://github.com/camunda/camunda-bpm-assert-scenario/blob/master/test/test-7.6/test/java/org/camunda/bpm/scenario/test/waitstates/EventBasedGatewayTest.java[Testing Scenerio Example]

##### Incident Handler Test Sample

[source,java]
----
include::../src/test/java/com/camunda/poc/starter/IncidentHandlerTest.java[]
----

### See it running
Go to cockpit http://localhost:8080/camunda/app/cockpit/

In cockpit find the Incident Process and locate the incident. You can resolve the incident by modifying the error variable.

## Architecture

//image:./docs/images/service-request-architecture.png[Service Request BPMN]
====
The incident handler can be used to handle incidents in systems outside of Camunda or in conjunction with Camunda.

In this example we continue to use Camunda Cockpit to store and handle the incidents and move the process forward after an incident is resolved but this does not have to be the case.

The handler could be used to push incidents to another system and the Camunda api could be used to then resolve incidents once resolved in another system. This is similar to the external task pattern as external tasks report incidents to the engine based on the external work.

Additionally we could generate and handle custom incidents if we chose; by throwing/createing custom incidents in listeners or delegates or even engine plugins.

The default Camunda incident handlers work by handling incidents generated when jobs fail (Async Continuations are ticked in the model) or when External Task workers report incidents
====



#### How does it work
====

In this example we override the default incident handlers with our custom incident handler but we still want to use the default behavior and handle Job failures and External task failures. This is accomplished by simple extending the default behavior `DefaultIncidentHandler` and registering our custom handler to handle Job and External task worker incidents.

Notice the Constructor takes the Handler type as a argument. This allows us to register the custom handler to handle the default incident types. We could potentially create are own incident types then easily register our custom incident type as well.
====
[source, java]
----
include::../src/main/java/com/camunda/poc/starter/incident/handler/plugin/MyCustomIncidentHandler.java[]
----

====

In this example the process engine configuration is utilized register our custom handler to handle Job and External task worker incidents. Notice we could easily register another incident handler with a custom type of our choosing. Then we would have to use the API to create incidents of that custom type.
====

NOTE: this is also an example using an engine plugin. Which is the primary extension point for adding custom code to the engine.

[source, java]
----
include::../src/main/java/com/camunda/poc/starter/incident/handler/plugin/MyCustomIncidentHandlerEnginePlugin.java[]
----

## Developing with this PoC Starter Project

#### Running the server for Dev

- Also note you can use spring-dev-tools to build front and back-end component in dev mode providing faster restarts and live-reload.

for dev mode run the following with the appropriate profiles
```
mvn spring-boot:run mvn spring-boot:run -Dspring.profiles.active=incident
```

WARNING: spring-dev-tools affects the way Camunda serializes objects into process vars and will cause serialization errors in some cases. So it is commented out in pom.xml by default.

### Externalizing Configuration

All the properties in the .properties files can be externalized.

Look at the **_application-prod.properties_** files for examples of utilizing environment variables with the app. This is particularly useful if your running in serverless environment and you cannot store property values in your code repo.


## Deploying the app

### Docker and Docker-Compose

Services are configure in the docker-compose.yaml to run the app in docker with a default network.

1. Uncomment the appropriate services for your application and profiles in the docker-compose.yaml located in the docker-compose directory.
2. Make sure to build the spring-boot app
3. run docker-compose up from the docker-compose directory


#### Environment configs

There are a few configurations you must add to Heroku for the app to work correctly

- JDBC_DATABASE_URL - This config is added for you. You wont see it in the Heroku dashboard. Run the following command to confirm this is set.
