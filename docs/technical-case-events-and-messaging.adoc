# Camunda messaging Example

Example using rabbitmq to create a pub/sub interaction with Camunda


## Running the use-case
IMPORTANT: Running the app once with no profile is necessary to initalize the Camunda database.
```
mvn spring-boot:run
```

Then again with the profiles
```
mvn spring-boot:run -Dspring.profiles.active=integration
```

**Profiles** can be specified at the command line when the application starts. The notation is as follows.

`-Dspring.profiles.active=integration`

Or you can use the application.properties file to specify the profile.

```yaml
spring.profiles.active: integration
```

IMPORTANT: Using Camunda Enterprise - it's necessary to request a Camunda Enterprise License. 


### Testing with Postman

Use the postman collection `Service-Request-PoC.postman_collection.json` in the `postman` folder.

With post-man you can move through the processes simulating REST requests to the app.

- starting the process with new service request
- completing user tasks
- correlating messages

### Testing with Java
Camunda allows developers to test in multiple scopes with the camunda-bpm-assert lib and the surrouding framework.
https://docs.camunda.org/manual/7.5/user-guide/testing/#junit-4[Testing Docs]

Camunda provides test coverage reports that integrate with the camunda-bpm-assert lib and the camunda-bpm-assert-scenario lib
https://github.com/camunda/camunda-bpm-process-test-coverage[Test Coverage]

camunda-bpm-assert-scenario is an abstraction on the camunda-bpm-assert lib
https://github.com/camunda/camunda-bpm-assert-scenario/blob/master/test/test-7.6/test/java/org/camunda/bpm/scenario/test/waitstates/EventBasedGatewayTest.java[Testing Scenerio Example]


### See it running
Go to cockpit

## Architecture

//image:./docs/images/service-request-architecture.png[Service Request BPMN]
====

====

### RabbitMQ AMQP Integration
The spring-boot app is using spring cloud streams.

https://spring.io/projects/spring-cloud-stream

====
The app has a has a single publisher and a single subscriber for the service-request-events topic.

```
spring.cloud.stream.bindings.publishServiceRequest.destination=service-request-events
spring.cloud.stream.bindings.subscribeServiceRequest.destination=service-request-events
```
See the `com.camunda.poc.starter.usecase.servicerequest.HazelCast.integration` package/folder for impl of publishers and subscribers.
====

====
A single subscriber is implemented `ServiceRequestEventSubscriber.java`; it simply gets the message from the topic and serialized into memory. Then it saves/caches the Service Request into the local db based on the event type.
====

====
Two publishers are implemented, `ServiceRequestCreateEventPublishingDelegate.java` and `ServiceRequestUpdateEventPublishingDelegate.java`. These publishers are also JavaDelegtes and are wired into the bpmn model and are executed during the process execution. This is a powerful pattern as it lets us control the execution of the workflow and handle errors incidents and more.

The publisher publishes a Contact

====


#### How does it work
====

====
IMPORTANT: The intention is to create a https://martinfowler.com/bliki/CQRS.html#:~:text=CQRS%20stands%20for%20Command%20Query,you%20use%20to%20read%20information[CQRS(Command Query Responsibility Segregation)] pattern for interaction. This can increase scalability while reducing complexity in distributed systems.

## Developing with this PoC Starter Project


#### Running the server for Dev

for dev mode run the following with the appropriate profiles
```
mvn spring-boot:run mvn spring-boot:run -Dspring.profiles.active=integration
```

WARNING: spring-dev-tools affects the way Camunda serializes objects into process vars and will cause serialization errors in some cases. So it is commented out in pom.xml by default.

#### Running RabbitMQ
NOTE: A simple RabbitMQ config is packaged into docker-compose. See `docker-compose` directory in the project home folder. Also you can run docker compose as follows.
```
 docker-compose up
```


### Externalizing Configuration

All the properties in the .properties files can be externalized.

Look at the **_application-prod.properties_** files for examples of utilizing environment variables with the app. This is particularly useful if your running in serverless environment and you cannot store property values in your code repo.


## Deploying the app

### Docker and Docker-Compose

Services are configure in the docker-compose.yaml to run the app in docker with a default network.

1. Uncomment the appropriate services for your application and profiles in the docker-compose.yaml located in the docker-compose directory.
2. Make sure to build the spring-boot app
3. run docker-compose up from the docker-compose directory


#### Environment configs

There are a few configurations you must add to Heroku for the app to work correctly

- JDBC_DATABASE_URL - This config is added for you. You wont see it in the Heroku dashboard. Run the following command to confirm this is set.

