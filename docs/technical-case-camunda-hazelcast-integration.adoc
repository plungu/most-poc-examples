# Camunda Hazelcast Integration Example

The purpose of this application is to have a starter for PoC and other less structured engagements. This enables the consultant to easily discuss and demonstrate common concepts and patterns without customizing the application. Additionally it can be used as a starter project in many cases.


## Running the use-case
IMPORTANT: Running the app once with no profile is necessary to initalize the Camunda database.
```
mvn spring-boot:run
```

Then again with the profiles
```
mvn spring-boot:run -Dspring.profiles.active=hazelcast
```

**Profiles** can be specified at the command line when the application starts. The notation is as follows.

`-Dspring.profiles.active=hazelcast`

Or you can use the application.properties file to specify the profile.

```yaml
spring.profiles.active: hazelcast
```

IMPORTANT: Using Camunda Enterprise - it's necessary to request a Camunda Enterprise License. 


### Testing with Postman

Use the postman collection `camunda-most-poc.postman_collection.json` in the `postman` folder.

With post-man you can move through the processes simulating REST requests to the app.

- starting the process with new service request
- completing user tasks
- correlating messages

### Testing with Java
Camunda allows developers to test in multiple scopes with the camunda-bpm-assert lib and the surrouding framework.
https://docs.camunda.org/manual/7.5/user-guide/testing/#junit-4[Testing Docs]

Camunda provides test coverage reports that integrate with the camunda-bpm-assert lib and the camunda-bpm-assert-scenario lib
https://github.com/camunda/camunda-bpm-process-test-coverage[Test Coverage]

camunda-bpm-assert-scenario is an abstraction on the camunda-bpm-assert lib
https://github.com/camunda/camunda-bpm-assert-scenario/blob/master/test/test-7.6/test/java/org/camunda/bpm/scenario/test/waitstates/EventBasedGatewayTest.java[Testing Scenerio Example]


### See it running
Go to cockpit

## Architecture

//image:./docs/images/service-request-architecture.png[Service Request BPMN]
====

====
NOTE: This is a typical pattern for micro-service architectures though the level of abstraction between components will vary from use-case to use-case.

### HazelCast Integration

====
====


### Handling Business Data and UI Integration

TIP: see the pattern described in the Camunda Best Practices https://camunda.com/best-practices/handling-data-in-processes/ and https://camunda.com/best-practices/enhancing-tasklists-with-business-data/


#### How does it work
====

====

IMPORTANT: The intention is to create a https://martinfowler.com/bliki/CQRS.html#:~:text=CQRS%20stands%20for%20Command%20Query,you%20use%20to%20read%20information[CQRS(Command Query Responsibility Segregation)] pattern for interaction. This can increase scalability while reducing complexity in distributed systems.

## Developing with this PoC Starter Project

#### Running the server for Dev

for dev mode run the following with the appropriate profiles
```
mvn spring-boot:run mvn spring-boot:run -Dspring.profiles.active=hazelcast
```

WARNING: spring-dev-tools affects the way Camunda serializes objects into process vars and will cause serialization errors in some cases. So it is commented out in pom.xml by default.

#### Running HazelCast
NOTE: A simple HazelCast congfig is packaged into docker-compose. See `docker-compose` directory in the project home folder. Also you can run docker compose as follows.
```
 docker-compose up
```
https://hub.docker.com/r/hazelcast/hazelcast[HazelCast docker image docs]

https://hazelcast.org/imdg/get-started/[HazelCast getting started]

link:Hazelcast_Architects_View.pdf[HazelCast Architecture Overview Doc]

### Externalizing Configuration

All the properties in the .properties files can be externalized.

Look at the **_application-prod.properties_** files for examples of utilizing environment variables with the app. This is particularly useful if your running in serverless environment and you cannot store property values in your code repo.


## Deploying the app

### Docker and Docker-Compose

Services are configure in the docker-compose.yaml to run the app in docker with a default network.

1. Uncomment the appropriate services for your application and profiles in the docker-compose.yaml located in the docker-compose directory.
2. Make sure to build the spring-boot app
3. run docker-compose up from the docker-compose directory


#### Environment configs

There are a few configurations you must add to Heroku for the app to work correctly

- JDBC_DATABASE_URL - This config is added for you. You wont see it in the Heroku dashboard. Run the following command to confirm this is set.

